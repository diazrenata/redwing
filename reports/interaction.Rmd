---
title: "Currency x time interactions"
author: Renata Diaz
date: "`r Sys.Date()`"
output: 
    github_document:
      toc: true
      df_print: kable

---

```{r setup, include=FALSE}
library(dplyr)
library(ggplot2)
library(drake)
theme_set(theme_bw())


## Set up the cache and config
db <- DBI::dbConnect(RSQLite::SQLite(), here::here("drake-cache-actual.sqlite"))
cache <- storr::storr_dbi("datatable", "keystable", db)
cache$del(key = "lock", namespace = "session")

loadd(all_results, cache = cache)

DBI::dbDisconnect(db)
rm(cache)
rm(db)

max10 <- read.csv(here::here("working_routes_max10.csv"))

all_results <- all_results %>%
  mutate(matssname = paste0("bbs_rtrg_", route, "_", statenum)) %>%
  filter(matssname %in% max10$matssname)


onetoone <- geom_abline(slope = 1, intercept = 0)
```
I **think** this may be a more valid way to get at the thing that bugs me.


So we are basically asking if the slope of energy change is proportionate to abundance, if the different currencies matter or not. 


I've been trying to get at this via a roundabout way of individual lms on the different currencies.


I think a more succinct and probably correct - given the way I interpret this stuff - way is to fit a lm() (or whatever, glm, nlme) of the structure `abundance ~ timeperiod * currency`. This asks whether: 

- abundance is different in different time periods
- the currencies have different intercepts
- and if the currencies differ in how different they are across different time periods.

The currencies are on vastly different scales, right; abundance is going to be in the hundreds while energy is in the hundreds of thousands. I tried it using them notscaled and it didn't work at all; any trend in abundance (or absence) would be swamped by the variable on the larger scale.

So here I am rescaling the variables and then putting them all in a lm of the above form, and then looking at the different trends for each currency and whether the currencies get different slopes. 

I **believe** this gets at "decoupling" more succinctly than a million lms and then histograms. 

And then in aggregate, looking at:

- how often biomass!=abundance, how often energy != abundance
- what's going on with the isd in these scenarios



```{r}
weird <- filter(all_results, abs(1 - fitted_ratio_caps_energy) < .1, abs(1 - fitted_ratio_caps_abundance) > .3)

## Set up the cache and config
db <- DBI::dbConnect(RSQLite::SQLite(), here::here("drake-cache-actual.sqlite"))
cache <- storr::storr_dbi("datatable", "keystable", db)
cache$del(key = "lock", namespace = "session")

loadd(bbs_rtrg_119_68, cache = cache)

gh <- bbs_rtrg_119_68

library(BBSsize)

gh_isd <- simulate_isd_ts(gh)

library(rwar)

gh_sv <- get_annual_svs(gh_isd$isd) %>%
  filter(year %in% c(1988:2018))  

ggplot(gh_sv, aes(year, abundance)) + geom_line() 

ggplot(gh_sv, aes(year, energy)) + geom_line() 

rangescale <- function(vect) {
  
  vectrange <- max(vect) - min(vect)
  
  vect = (vect - min(vect)) / vectrange
  
  vect
  
}

gh_caps <- pull_caps(gh_sv, c(1988:1992), c(2014:2018))%>%
  mutate(energy = rangescale((energy)),
        abundance = rangescale((abundance)),
        biomass = rangescale(biomass))

gh_caps_long <- gh_caps %>%
  tidyr::pivot_longer(c(-year, -timeperiod), names_to = "currency", values_to = "val")

gh_caps_forlm <- gh_caps_long %>%
  filter(currency %in% c("energy", "abundance", "biomass"))

ggplot(gh_caps_long, aes(timeperiod, val, color = currency)) + geom_point()+ facet_wrap(vars(currency), scales = "free_y")

gh_lm <- lm(val ~ timeperiod * currency, data = gh_caps_forlm)

summary(gh_lm)


library(emmeans)


gh_contrasts <- emmeans(gh_lm, specs = ~ timeperiod | currency)

gh_contrast_sig <- as.data.frame(pairs(gh_contrasts)) %>%
  dplyr::select(currency, p.value) %>%
  tidyr::pivot_wider(names_from = currency, values_from = p.value, names_glue = "{currency}_contrast{.value}")

cap_lm = gh_lm


  cap_lm_results <- summary(cap_lm)

  cap_lm_ps <- cap_lm_results$coefficients


  cap_contrasts <- emmeans::emmeans(cap_lm, specs = ~ timeperiod | currency)

  cap_contrast_sig <- as.data.frame(pairs(cap_contrasts)) %>%
    dplyr::select(currency, p.value) %>%
    tidyr::pivot_wider(names_from = currency, values_from = p.value, names_glue = "{currency}_contrast{.value}")

  cap_p <- pf(cap_lm_results$fstatistic[1], cap_lm_results$fstatistic[2], cap_lm_results$fstatistic[3], lower.tail = F)
  cap_lm_results_wide <- cap_lm_ps %>%
    as.data.frame() %>%
    dplyr::mutate(coef_name = row.names(.)) %>%
    tidyr::pivot_wider(names_from = coef_name, values_from = c("Estimate", "Std. Error", "t value", "Pr(>|t|)")) %>%
    dplyr::mutate(overall_p = cap_p,
                  overall_r2 = cap_lm_results$r.squared) %>%
    cbind(cap_contrast_sig)

```

```{r}
gh_lm_fit <- gh_caps_forlm %>%
  mutate(lm_fit = gh_lm$fitted.values)

ggplot(gh_lm_fit, aes(year, val, color = currency)) + geom_point() + geom_point(aes(y = lm_fit), shape = 3) + facet_wrap(vars(currency))

```


So not going further down the nlme cul-de-sac at the moment.

```{r}

gh_lm

gh_lm_results <- summary(gh_lm)

gh_lm_ps <- gh_lm_results$coefficients


gh_p <- pf(gh_lm_results$fstatistic[1], gh_lm_results$fstatistic[2], gh_lm_results$fstatistic[3], lower.tail = F)
gh_lm_results_wide <- gh_lm_ps %>%
  as.data.frame() %>%
  mutate(coef_name = row.names(.)) %>%
  tidyr::pivot_wider(names_from = coef_name, values_from = c("Estimate", "Std. Error", "t value", "Pr(>|t|)")) %>%
  mutate(overall_p = gh_p,
         overall_r2 = gh_lm_results$r.squared)
gh_lm_results_wide


```
